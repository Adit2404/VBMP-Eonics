//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://127.0.0.1:8080";
    }

    /**
     * @return OK
     */
    getVacancy(id: number): Promise<Vacancy> {
        let url_ = this.baseUrl + "/api/vacancies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVacancy(_response);
        });
    }

    protected processGetVacancy(response: Response): Promise<Vacancy> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Vacancy.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Vacancy>(null as any);
    }

    /**
     * @return OK
     */
    updateVacancy(id: number, body: Vacancy): Promise<Vacancy> {
        let url_ = this.baseUrl + "/api/vacancies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateVacancy(_response);
        });
    }

    protected processUpdateVacancy(response: Response): Promise<Vacancy> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Vacancy.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Vacancy>(null as any);
    }

    /**
     * @return OK
     */
    deleteVacancy(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/vacancies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteVacancy(_response);
        });
    }

    protected processDeleteVacancy(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    partialUpdateVacancy(id: number, body: Vacancy): Promise<Vacancy> {
        let url_ = this.baseUrl + "/api/vacancies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPartialUpdateVacancy(_response);
        });
    }

    protected processPartialUpdateVacancy(response: Response): Promise<Vacancy> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Vacancy.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Vacancy>(null as any);
    }

    /**
     * @return OK
     */
    getRemark(id: number): Promise<Remark> {
        let url_ = this.baseUrl + "/api/remarks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRemark(_response);
        });
    }

    protected processGetRemark(response: Response): Promise<Remark> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Remark.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Remark>(null as any);
    }

    /**
     * @return OK
     */
    updateRemark(id: number, body: Remark): Promise<Remark> {
        let url_ = this.baseUrl + "/api/remarks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRemark(_response);
        });
    }

    protected processUpdateRemark(response: Response): Promise<Remark> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Remark.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Remark>(null as any);
    }

    /**
     * @return OK
     */
    deleteRemark(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/remarks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRemark(_response);
        });
    }

    protected processDeleteRemark(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    partialUpdateRemark(id: number, body: Remark): Promise<Remark> {
        let url_ = this.baseUrl + "/api/remarks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPartialUpdateRemark(_response);
        });
    }

    protected processPartialUpdateRemark(response: Response): Promise<Remark> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Remark.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Remark>(null as any);
    }

    /**
     * @return OK
     */
    getExperience(id: string): Promise<Experience> {
        let url_ = this.baseUrl + "/api/experiences/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExperience(_response);
        });
    }

    protected processGetExperience(response: Response): Promise<Experience> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Experience.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Experience>(null as any);
    }

    /**
     * @return OK
     */
    updateExperience(id: string, body: Experience): Promise<Experience> {
        let url_ = this.baseUrl + "/api/experiences/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateExperience(_response);
        });
    }

    protected processUpdateExperience(response: Response): Promise<Experience> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Experience.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Experience>(null as any);
    }

    /**
     * @return OK
     */
    deleteExperience(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/experiences/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteExperience(_response);
        });
    }

    protected processDeleteExperience(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    partialUpdateExperience(id: string, body: Experience): Promise<Experience> {
        let url_ = this.baseUrl + "/api/experiences/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPartialUpdateExperience(_response);
        });
    }

    protected processPartialUpdateExperience(response: Response): Promise<Experience> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Experience.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Experience>(null as any);
    }

    /**
     * @return OK
     */
    getEducation(id: string): Promise<Education> {
        let url_ = this.baseUrl + "/api/educations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEducation(_response);
        });
    }

    protected processGetEducation(response: Response): Promise<Education> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Education.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Education>(null as any);
    }

    /**
     * @return OK
     */
    updateEducation(id: string, body: Education): Promise<Education> {
        let url_ = this.baseUrl + "/api/educations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEducation(_response);
        });
    }

    protected processUpdateEducation(response: Response): Promise<Education> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Education.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Education>(null as any);
    }

    /**
     * @return OK
     */
    deleteEducation(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/educations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEducation(_response);
        });
    }

    protected processDeleteEducation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    partialUpdateEducation(id: string, body: Education): Promise<Education> {
        let url_ = this.baseUrl + "/api/educations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPartialUpdateEducation(_response);
        });
    }

    protected processPartialUpdateEducation(response: Response): Promise<Education> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Education.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Education>(null as any);
    }

    /**
     * @return OK
     */
    getCompanyUser(id: number): Promise<CompanyUser> {
        let url_ = this.baseUrl + "/api/company-users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompanyUser(_response);
        });
    }

    protected processGetCompanyUser(response: Response): Promise<CompanyUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyUser.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyUser>(null as any);
    }

    /**
     * @return OK
     */
    updateCompanyUser(id: number, body: CompanyUser): Promise<CompanyUser> {
        let url_ = this.baseUrl + "/api/company-users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCompanyUser(_response);
        });
    }

    protected processUpdateCompanyUser(response: Response): Promise<CompanyUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyUser.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyUser>(null as any);
    }

    /**
     * @return OK
     */
    deleteCompanyUser(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/company-users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCompanyUser(_response);
        });
    }

    protected processDeleteCompanyUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    partialUpdateCompanyUser(id: number, body: CompanyUser): Promise<CompanyUser> {
        let url_ = this.baseUrl + "/api/company-users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPartialUpdateCompanyUser(_response);
        });
    }

    protected processPartialUpdateCompanyUser(response: Response): Promise<CompanyUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyUser.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyUser>(null as any);
    }

    /**
     * @return OK
     */
    getCompanyApplicationStatus(id: number): Promise<CompanyApplicationStatus> {
        let url_ = this.baseUrl + "/api/company-application-statuses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompanyApplicationStatus(_response);
        });
    }

    protected processGetCompanyApplicationStatus(response: Response): Promise<CompanyApplicationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyApplicationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyApplicationStatus>(null as any);
    }

    /**
     * @return OK
     */
    updateCompanyApplicationStatus(id: number, body: CompanyApplicationStatus): Promise<CompanyApplicationStatus> {
        let url_ = this.baseUrl + "/api/company-application-statuses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCompanyApplicationStatus(_response);
        });
    }

    protected processUpdateCompanyApplicationStatus(response: Response): Promise<CompanyApplicationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyApplicationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyApplicationStatus>(null as any);
    }

    /**
     * @return OK
     */
    deleteCompanyApplicationStatus(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/company-application-statuses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCompanyApplicationStatus(_response);
        });
    }

    protected processDeleteCompanyApplicationStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    partialUpdateCompanyApplicationStatus(id: number, body: CompanyApplicationStatus): Promise<CompanyApplicationStatus> {
        let url_ = this.baseUrl + "/api/company-application-statuses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPartialUpdateCompanyApplicationStatus(_response);
        });
    }

    protected processPartialUpdateCompanyApplicationStatus(response: Response): Promise<CompanyApplicationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyApplicationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyApplicationStatus>(null as any);
    }

    /**
     * @return OK
     */
    getCompany(id: string): Promise<Company> {
        let url_ = this.baseUrl + "/api/companies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompany(_response);
        });
    }

    protected processGetCompany(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(null as any);
    }

    /**
     * @return OK
     */
    updateCompany(id: string, body: Company): Promise<Company> {
        let url_ = this.baseUrl + "/api/companies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCompany(_response);
        });
    }

    protected processUpdateCompany(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(null as any);
    }

    /**
     * @return OK
     */
    deleteCompany(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/companies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCompany(_response);
        });
    }

    protected processDeleteCompany(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    partialUpdateCompany(id: string, body: Company): Promise<Company> {
        let url_ = this.baseUrl + "/api/companies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPartialUpdateCompany(_response);
        });
    }

    protected processPartialUpdateCompany(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(null as any);
    }

    /**
     * @return OK
     */
    getCandidate(id: number): Promise<Candidate> {
        let url_ = this.baseUrl + "/api/candidates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCandidate(_response);
        });
    }

    protected processGetCandidate(response: Response): Promise<Candidate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Candidate.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Candidate>(null as any);
    }

    /**
     * @return OK
     */
    updateCandidate(id: number, body: Candidate): Promise<Candidate> {
        let url_ = this.baseUrl + "/api/candidates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCandidate(_response);
        });
    }

    protected processUpdateCandidate(response: Response): Promise<Candidate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Candidate.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Candidate>(null as any);
    }

    /**
     * @return OK
     */
    deleteCandidate(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/candidates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCandidate(_response);
        });
    }

    protected processDeleteCandidate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    partialUpdateCandidate(id: number, body: Candidate): Promise<Candidate> {
        let url_ = this.baseUrl + "/api/candidates/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPartialUpdateCandidate(_response);
        });
    }

    protected processPartialUpdateCandidate(response: Response): Promise<Candidate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Candidate.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Candidate>(null as any);
    }

    /**
     * @return OK
     */
    getAtsUser(id: number): Promise<AtsUser> {
        let url_ = this.baseUrl + "/api/ats-users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAtsUser(_response);
        });
    }

    protected processGetAtsUser(response: Response): Promise<AtsUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AtsUser.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AtsUser>(null as any);
    }

    /**
     * @return OK
     */
    updateAtsUser(id: number, body: AtsUser): Promise<AtsUser> {
        let url_ = this.baseUrl + "/api/ats-users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAtsUser(_response);
        });
    }

    protected processUpdateAtsUser(response: Response): Promise<AtsUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AtsUser.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AtsUser>(null as any);
    }

    /**
     * @return OK
     */
    deleteAtsUser(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ats-users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAtsUser(_response);
        });
    }

    protected processDeleteAtsUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    partialUpdateAtsUser(id: number, body: AtsUser): Promise<AtsUser> {
        let url_ = this.baseUrl + "/api/ats-users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPartialUpdateAtsUser(_response);
        });
    }

    protected processPartialUpdateAtsUser(response: Response): Promise<AtsUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AtsUser.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AtsUser>(null as any);
    }

    /**
     * @return OK
     */
    getAtsApplication(id: number): Promise<AtsApplication> {
        let url_ = this.baseUrl + "/api/ats-applications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAtsApplication(_response);
        });
    }

    protected processGetAtsApplication(response: Response): Promise<AtsApplication> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AtsApplication.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AtsApplication>(null as any);
    }

    /**
     * @return OK
     */
    updateAtsApplication(id: number, body: AtsApplication): Promise<AtsApplication> {
        let url_ = this.baseUrl + "/api/ats-applications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAtsApplication(_response);
        });
    }

    protected processUpdateAtsApplication(response: Response): Promise<AtsApplication> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AtsApplication.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AtsApplication>(null as any);
    }

    /**
     * @return OK
     */
    deleteAtsApplication(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ats-applications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAtsApplication(_response);
        });
    }

    protected processDeleteAtsApplication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    partialUpdateAtsApplication(id: number, body: AtsApplication): Promise<AtsApplication> {
        let url_ = this.baseUrl + "/api/ats-applications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPartialUpdateAtsApplication(_response);
        });
    }

    protected processPartialUpdateAtsApplication(response: Response): Promise<AtsApplication> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AtsApplication.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AtsApplication>(null as any);
    }

    /**
     * @param page (optional) Zero-based page index (0..N)
     * @param size (optional) The size of the page to be returned
     * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @return OK
     */
    getAllUsers(page: number | undefined, size: number | undefined, sort: string[] | undefined): Promise<AdminUserDTO[]> {
        let url_ = this.baseUrl + "/api/admin/users?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllUsers(_response);
        });
    }

    protected processGetAllUsers(response: Response): Promise<AdminUserDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdminUserDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AdminUserDTO[]>(null as any);
    }

    /**
     * @return OK
     */
    updateUser(body: AdminUserDTO): Promise<AdminUserDTO> {
        let url_ = this.baseUrl + "/api/admin/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<AdminUserDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminUserDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AdminUserDTO>(null as any);
    }

    /**
     * @return OK
     */
    createUser(body: AdminUserDTO): Promise<User> {
        let url_ = this.baseUrl + "/api/admin/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @return OK
     */
    getAllVacancies(): Promise<Vacancy[]> {
        let url_ = this.baseUrl + "/api/vacancies";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllVacancies(_response);
        });
    }

    protected processGetAllVacancies(response: Response): Promise<Vacancy[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Vacancy.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Vacancy[]>(null as any);
    }

    /**
     * @return OK
     */
    createVacancy(body: Vacancy): Promise<Vacancy> {
        let url_ = this.baseUrl + "/api/vacancies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateVacancy(_response);
        });
    }

    protected processCreateVacancy(response: Response): Promise<Vacancy> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Vacancy.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Vacancy>(null as any);
    }

    /**
     * @return OK
     */
    getAllRemarks(): Promise<Remark[]> {
        let url_ = this.baseUrl + "/api/remarks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRemarks(_response);
        });
    }

    protected processGetAllRemarks(response: Response): Promise<Remark[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Remark.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Remark[]>(null as any);
    }

    /**
     * @return OK
     */
    createRemark(body: Remark): Promise<Remark> {
        let url_ = this.baseUrl + "/api/remarks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateRemark(_response);
        });
    }

    protected processCreateRemark(response: Response): Promise<Remark> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Remark.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Remark>(null as any);
    }

    /**
     * @return Created
     */
    registerAccount(body: ManagedUserVM): Promise<void> {
        let url_ = this.baseUrl + "/api/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegisterAccount(_response);
        });
    }

    protected processRegisterAccount(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getAllExperiences(): Promise<Experience[]> {
        let url_ = this.baseUrl + "/api/experiences";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllExperiences(_response);
        });
    }

    protected processGetAllExperiences(response: Response): Promise<Experience[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Experience.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Experience[]>(null as any);
    }

    /**
     * @return OK
     */
    createExperience(body: Experience): Promise<Experience> {
        let url_ = this.baseUrl + "/api/experiences";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateExperience(_response);
        });
    }

    protected processCreateExperience(response: Response): Promise<Experience> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Experience.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Experience>(null as any);
    }

    /**
     * @return OK
     */
    getAllEducations(): Promise<Education[]> {
        let url_ = this.baseUrl + "/api/educations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllEducations(_response);
        });
    }

    protected processGetAllEducations(response: Response): Promise<Education[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Education.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Education[]>(null as any);
    }

    /**
     * @return OK
     */
    createEducation(body: Education): Promise<Education> {
        let url_ = this.baseUrl + "/api/educations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEducation(_response);
        });
    }

    protected processCreateEducation(response: Response): Promise<Education> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Education.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Education>(null as any);
    }

    /**
     * @return OK
     */
    getAllCompanyUsers(): Promise<CompanyUser[]> {
        let url_ = this.baseUrl + "/api/company-users";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompanyUsers(_response);
        });
    }

    protected processGetAllCompanyUsers(response: Response): Promise<CompanyUser[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanyUser.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyUser[]>(null as any);
    }

    /**
     * @return OK
     */
    createCompanyUser(body: CompanyUser): Promise<CompanyUser> {
        let url_ = this.baseUrl + "/api/company-users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCompanyUser(_response);
        });
    }

    protected processCreateCompanyUser(response: Response): Promise<CompanyUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyUser.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyUser>(null as any);
    }

    /**
     * @return OK
     */
    getAllCompanyApplicationStatuses(): Promise<CompanyApplicationStatus[]> {
        let url_ = this.baseUrl + "/api/company-application-statuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompanyApplicationStatuses(_response);
        });
    }

    protected processGetAllCompanyApplicationStatuses(response: Response): Promise<CompanyApplicationStatus[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanyApplicationStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyApplicationStatus[]>(null as any);
    }

    /**
     * @return OK
     */
    createCompanyApplicationStatus(body: CompanyApplicationStatus): Promise<CompanyApplicationStatus> {
        let url_ = this.baseUrl + "/api/company-application-statuses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCompanyApplicationStatus(_response);
        });
    }

    protected processCreateCompanyApplicationStatus(response: Response): Promise<CompanyApplicationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyApplicationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyApplicationStatus>(null as any);
    }

    /**
     * @return OK
     */
    getAllCompanies(): Promise<Company[]> {
        let url_ = this.baseUrl + "/api/companies";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompanies(_response);
        });
    }

    protected processGetAllCompanies(response: Response): Promise<Company[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Company.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company[]>(null as any);
    }

    /**
     * @return OK
     */
    createCompany(body: Company): Promise<Company> {
        let url_ = this.baseUrl + "/api/companies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCompany(_response);
        });
    }

    protected processCreateCompany(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(null as any);
    }

    /**
     * @return OK
     */
    getAllCandidates(): Promise<Candidate[]> {
        let url_ = this.baseUrl + "/api/candidates";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCandidates(_response);
        });
    }

    protected processGetAllCandidates(response: Response): Promise<Candidate[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Candidate.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Candidate[]>(null as any);
    }

    /**
     * @return OK
     */
    createCandidate(body: Candidate): Promise<Candidate> {
        let url_ = this.baseUrl + "/api/candidates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCandidate(_response);
        });
    }

    protected processCreateCandidate(response: Response): Promise<Candidate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Candidate.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Candidate>(null as any);
    }

    /**
     * @return OK
     */
    isAuthenticated(): Promise<string> {
        let url_ = this.baseUrl + "/api/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsAuthenticated(_response);
        });
    }

    protected processIsAuthenticated(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return OK
     */
    authorize(body: LoginVM): Promise<JWTToken> {
        let url_ = this.baseUrl + "/api/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuthorize(_response);
        });
    }

    protected processAuthorize(response: Response): Promise<JWTToken> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JWTToken.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JWTToken>(null as any);
    }

    /**
     * @param filter (optional) 
     * @return OK
     */
    getAllAtsUsers(filter: string | undefined): Promise<AtsUser[]> {
        let url_ = this.baseUrl + "/api/ats-users?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllAtsUsers(_response);
        });
    }

    protected processGetAllAtsUsers(response: Response): Promise<AtsUser[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AtsUser.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AtsUser[]>(null as any);
    }

    /**
     * @return OK
     */
    createAtsUser(body: AtsUser): Promise<AtsUser> {
        let url_ = this.baseUrl + "/api/ats-users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateAtsUser(_response);
        });
    }

    protected processCreateAtsUser(response: Response): Promise<AtsUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AtsUser.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AtsUser>(null as any);
    }

    /**
     * @return OK
     */
    getAllAtsApplications(): Promise<AtsApplication[]> {
        let url_ = this.baseUrl + "/api/ats-applications";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllAtsApplications(_response);
        });
    }

    protected processGetAllAtsApplications(response: Response): Promise<AtsApplication[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AtsApplication.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AtsApplication[]>(null as any);
    }

    /**
     * @return OK
     */
    createAtsApplication(body: AtsApplication): Promise<AtsApplication> {
        let url_ = this.baseUrl + "/api/ats-applications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateAtsApplication(_response);
        });
    }

    protected processCreateAtsApplication(response: Response): Promise<AtsApplication> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AtsApplication.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AtsApplication>(null as any);
    }

    /**
     * @return OK
     */
    getAccount(): Promise<AdminUserDTO> {
        let url_ = this.baseUrl + "/api/account";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAccount(_response);
        });
    }

    protected processGetAccount(response: Response): Promise<AdminUserDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminUserDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AdminUserDTO>(null as any);
    }

    /**
     * @return OK
     */
    saveAccount(body: AdminUserDTO): Promise<void> {
        let url_ = this.baseUrl + "/api/account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveAccount(_response);
        });
    }

    protected processSaveAccount(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    requestPasswordReset(body: string): Promise<void> {
        let url_ = this.baseUrl + "/api/account/reset-password/init";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestPasswordReset(_response);
        });
    }

    protected processRequestPasswordReset(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    finishPasswordReset(body: KeyAndPasswordVM): Promise<void> {
        let url_ = this.baseUrl + "/api/account/reset-password/finish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFinishPasswordReset(_response);
        });
    }

    protected processFinishPasswordReset(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    changePassword(body: PasswordChangeDTO): Promise<void> {
        let url_ = this.baseUrl + "/api/account/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) Zero-based page index (0..N)
     * @param size (optional) The size of the page to be returned
     * @param sort (optional) Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @return OK
     */
    getAllPublicUsers(page: number | undefined, size: number | undefined, sort: string[] | undefined): Promise<UserDTO[]> {
        let url_ = this.baseUrl + "/api/users?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPublicUsers(_response);
        });
    }

    protected processGetAllPublicUsers(response: Response): Promise<UserDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDTO[]>(null as any);
    }

    /**
     * @return OK
     */
    getAuthorities(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/authorities";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAuthorities(_response);
        });
    }

    protected processGetAuthorities(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @return OK
     */
    getUser(login: string): Promise<AdminUserDTO> {
        let url_ = this.baseUrl + "/api/admin/users/{login}";
        if (login === undefined || login === null)
            throw new Error("The parameter 'login' must be defined.");
        url_ = url_.replace("{login}", encodeURIComponent("" + login));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<AdminUserDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminUserDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AdminUserDTO>(null as any);
    }

    /**
     * @return OK
     */
    deleteUser(login: string): Promise<void> {
        let url_ = this.baseUrl + "/api/admin/users/{login}";
        if (login === undefined || login === null)
            throw new Error("The parameter 'login' must be defined.");
        url_ = url_.replace("{login}", encodeURIComponent("" + login));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    activateAccount(key: string): Promise<void> {
        let url_ = this.baseUrl + "/api/activate?";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined and cannot be null.");
        else
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActivateAccount(_response);
        });
    }

    protected processActivateAccount(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AtsApplication implements IAtsApplication {
    id?: number;
    date?: Date;
    remarks?: Remark[];
    candidate?: Candidate;
    vacancy?: Vacancy;
    companyApplicationStatus?: CompanyApplicationStatus;

    [key: string]: any;

    constructor(data?: IAtsApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            if (Array.isArray(_data["remarks"])) {
                this.remarks = [] as any;
                for (let item of _data["remarks"])
                    this.remarks!.push(Remark.fromJS(item));
            }
            this.candidate = _data["candidate"] ? Candidate.fromJS(_data["candidate"]) : <any>undefined;
            this.vacancy = _data["vacancy"] ? Vacancy.fromJS(_data["vacancy"]) : <any>undefined;
            this.companyApplicationStatus = _data["companyApplicationStatus"] ? CompanyApplicationStatus.fromJS(_data["companyApplicationStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AtsApplication {
        data = typeof data === 'object' ? data : {};
        let result = new AtsApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        if (Array.isArray(this.remarks)) {
            data["remarks"] = [];
            for (let item of this.remarks)
                data["remarks"].push(item.toJSON());
        }
        data["candidate"] = this.candidate ? this.candidate.toJSON() : <any>undefined;
        data["vacancy"] = this.vacancy ? this.vacancy.toJSON() : <any>undefined;
        data["companyApplicationStatus"] = this.companyApplicationStatus ? this.companyApplicationStatus.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAtsApplication {
    id?: number;
    date?: Date;
    remarks?: Remark[];
    candidate?: Candidate;
    vacancy?: Vacancy;
    companyApplicationStatus?: CompanyApplicationStatus;

    [key: string]: any;
}

export class Candidate implements ICandidate {
    id?: number;

    [key: string]: any;

    constructor(data?: ICandidate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Candidate {
        data = typeof data === 'object' ? data : {};
        let result = new Candidate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ICandidate {
    id?: number;

    [key: string]: any;
}

export class Company implements ICompany {
    id?: string;
    companySize?: number;
    type?: string;
    video?: string[];
    videoContentType?: string;

    [key: string]: any;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.companySize = _data["companySize"];
            this.type = _data["type"];
            if (Array.isArray(_data["video"])) {
                this.video = [] as any;
                for (let item of _data["video"])
                    this.video!.push(item);
            }
            this.videoContentType = _data["videoContentType"];
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["companySize"] = this.companySize;
        data["type"] = this.type;
        if (Array.isArray(this.video)) {
            data["video"] = [];
            for (let item of this.video)
                data["video"].push(item);
        }
        data["videoContentType"] = this.videoContentType;
        return data;
    }
}

export interface ICompany {
    id?: string;
    companySize?: number;
    type?: string;
    video?: string[];
    videoContentType?: string;

    [key: string]: any;
}

export class CompanyApplicationStatus implements ICompanyApplicationStatus {
    id?: number;
    name?: string;

    [key: string]: any;

    constructor(data?: ICompanyApplicationStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CompanyApplicationStatus {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyApplicationStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICompanyApplicationStatus {
    id?: number;
    name?: string;

    [key: string]: any;
}

export class CompanyUser implements ICompanyUser {
    id?: number;

    [key: string]: any;

    constructor(data?: ICompanyUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CompanyUser {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ICompanyUser {
    id?: number;

    [key: string]: any;
}

export class Remark implements IRemark {
    id?: number;
    message?: string;
    date?: Date;
    atsApplication?: AtsApplication;
    companyUser?: CompanyUser;
    candidate?: Candidate;

    [key: string]: any;

    constructor(data?: IRemark) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.message = _data["message"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.atsApplication = _data["atsApplication"] ? AtsApplication.fromJS(_data["atsApplication"]) : <any>undefined;
            this.companyUser = _data["companyUser"] ? CompanyUser.fromJS(_data["companyUser"]) : <any>undefined;
            this.candidate = _data["candidate"] ? Candidate.fromJS(_data["candidate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Remark {
        data = typeof data === 'object' ? data : {};
        let result = new Remark();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["message"] = this.message;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["atsApplication"] = this.atsApplication ? this.atsApplication.toJSON() : <any>undefined;
        data["companyUser"] = this.companyUser ? this.companyUser.toJSON() : <any>undefined;
        data["candidate"] = this.candidate ? this.candidate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRemark {
    id?: number;
    message?: string;
    date?: Date;
    atsApplication?: AtsApplication;
    companyUser?: CompanyUser;
    candidate?: Candidate;

    [key: string]: any;
}

export class Vacancy implements IVacancy {
    id?: number;
    name?: string;
    dateOfPosting?: Date;
    description?: string;
    employmentType?: string;
    location?: string;
    video?: string[];
    videoContentType?: string;
    status?: string;
    isOpen?: boolean;
    atsApplications?: AtsApplication[];
    company?: Company;

    [key: string]: any;

    constructor(data?: IVacancy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.dateOfPosting = _data["dateOfPosting"] ? new Date(_data["dateOfPosting"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.employmentType = _data["employmentType"];
            this.location = _data["location"];
            if (Array.isArray(_data["video"])) {
                this.video = [] as any;
                for (let item of _data["video"])
                    this.video!.push(item);
            }
            this.videoContentType = _data["videoContentType"];
            this.status = _data["status"];
            this.isOpen = _data["isOpen"];
            if (Array.isArray(_data["atsApplications"])) {
                this.atsApplications = [] as any;
                for (let item of _data["atsApplications"])
                    this.atsApplications!.push(AtsApplication.fromJS(item));
            }
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Vacancy {
        data = typeof data === 'object' ? data : {};
        let result = new Vacancy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["dateOfPosting"] = this.dateOfPosting ? formatDate(this.dateOfPosting) : <any>undefined;
        data["description"] = this.description;
        data["employmentType"] = this.employmentType;
        data["location"] = this.location;
        if (Array.isArray(this.video)) {
            data["video"] = [];
            for (let item of this.video)
                data["video"].push(item);
        }
        data["videoContentType"] = this.videoContentType;
        data["status"] = this.status;
        data["isOpen"] = this.isOpen;
        if (Array.isArray(this.atsApplications)) {
            data["atsApplications"] = [];
            for (let item of this.atsApplications)
                data["atsApplications"].push(item.toJSON());
        }
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVacancy {
    id?: number;
    name?: string;
    dateOfPosting?: Date;
    description?: string;
    employmentType?: string;
    location?: string;
    video?: string[];
    videoContentType?: string;
    status?: string;
    isOpen?: boolean;
    atsApplications?: AtsApplication[];
    company?: Company;

    [key: string]: any;
}

/** not an ignored comment */
export class Experience implements IExperience {
    id?: string;
    title?: string;
    company?: string;
    location?: string;
    sdate?: Date;
    edate?: Date;
    description?: string;
    candidate?: Candidate;

    [key: string]: any;

    constructor(data?: IExperience) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.title = _data["title"];
            this.company = _data["company"];
            this.location = _data["location"];
            this.sdate = _data["sdate"] ? new Date(_data["sdate"].toString()) : <any>undefined;
            this.edate = _data["edate"] ? new Date(_data["edate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.candidate = _data["candidate"] ? Candidate.fromJS(_data["candidate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Experience {
        data = typeof data === 'object' ? data : {};
        let result = new Experience();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["title"] = this.title;
        data["company"] = this.company;
        data["location"] = this.location;
        data["sdate"] = this.sdate ? formatDate(this.sdate) : <any>undefined;
        data["edate"] = this.edate ? formatDate(this.edate) : <any>undefined;
        data["description"] = this.description;
        data["candidate"] = this.candidate ? this.candidate.toJSON() : <any>undefined;
        return data;
    }
}

/** not an ignored comment */
export interface IExperience {
    id?: string;
    title?: string;
    company?: string;
    location?: string;
    sdate?: Date;
    edate?: Date;
    description?: string;
    candidate?: Candidate;

    [key: string]: any;
}

export class Education implements IEducation {
    id?: string;
    title?: string;
    company?: string;
    location?: string;
    sdate?: Date;
    edate?: Date;
    description?: string;
    candidate?: Candidate;

    [key: string]: any;

    constructor(data?: IEducation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.title = _data["title"];
            this.company = _data["company"];
            this.location = _data["location"];
            this.sdate = _data["sdate"] ? new Date(_data["sdate"].toString()) : <any>undefined;
            this.edate = _data["edate"] ? new Date(_data["edate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.candidate = _data["candidate"] ? Candidate.fromJS(_data["candidate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Education {
        data = typeof data === 'object' ? data : {};
        let result = new Education();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["title"] = this.title;
        data["company"] = this.company;
        data["location"] = this.location;
        data["sdate"] = this.sdate ? formatDate(this.sdate) : <any>undefined;
        data["edate"] = this.edate ? formatDate(this.edate) : <any>undefined;
        data["description"] = this.description;
        data["candidate"] = this.candidate ? this.candidate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEducation {
    id?: string;
    title?: string;
    company?: string;
    location?: string;
    sdate?: Date;
    edate?: Date;
    description?: string;
    candidate?: Candidate;

    [key: string]: any;
}

export class AtsUser implements IAtsUser {
    id?: number;
    firstName?: string;
    lastName?: string;
    email?: string;
    phoneNumber?: string;
    userId?: string;
    video?: string[];
    videoContentType?: string;
    cv?: string[];
    cvContentType?: string;
    password?: string;
    usertype?: string;
    streetAddress?: string;
    postalCode?: string;
    city?: string;
    stateProvince?: string;

    [key: string]: any;

    constructor(data?: IAtsUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.userId = _data["userId"];
            if (Array.isArray(_data["video"])) {
                this.video = [] as any;
                for (let item of _data["video"])
                    this.video!.push(item);
            }
            this.videoContentType = _data["videoContentType"];
            if (Array.isArray(_data["cv"])) {
                this.cv = [] as any;
                for (let item of _data["cv"])
                    this.cv!.push(item);
            }
            this.cvContentType = _data["cvContentType"];
            this.password = _data["password"];
            this.usertype = _data["usertype"];
            this.streetAddress = _data["streetAddress"];
            this.postalCode = _data["postalCode"];
            this.city = _data["city"];
            this.stateProvince = _data["stateProvince"];
        }
    }

    static fromJS(data: any): AtsUser {
        data = typeof data === 'object' ? data : {};
        let result = new AtsUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["userId"] = this.userId;
        if (Array.isArray(this.video)) {
            data["video"] = [];
            for (let item of this.video)
                data["video"].push(item);
        }
        data["videoContentType"] = this.videoContentType;
        if (Array.isArray(this.cv)) {
            data["cv"] = [];
            for (let item of this.cv)
                data["cv"].push(item);
        }
        data["cvContentType"] = this.cvContentType;
        data["password"] = this.password;
        data["usertype"] = this.usertype;
        data["streetAddress"] = this.streetAddress;
        data["postalCode"] = this.postalCode;
        data["city"] = this.city;
        data["stateProvince"] = this.stateProvince;
        return data;
    }
}

export interface IAtsUser {
    id?: number;
    firstName?: string;
    lastName?: string;
    email?: string;
    phoneNumber?: string;
    userId?: string;
    video?: string[];
    videoContentType?: string;
    cv?: string[];
    cvContentType?: string;
    password?: string;
    usertype?: string;
    streetAddress?: string;
    postalCode?: string;
    city?: string;
    stateProvince?: string;

    [key: string]: any;
}

export class AdminUserDTO implements IAdminUserDTO {
    id?: number;
    login!: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    imageUrl?: string;
    activated?: boolean;
    langKey?: string;
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    authorities?: string[];

    [key: string]: any;

    constructor(data?: IAdminUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.login = _data["login"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.imageUrl = _data["imageUrl"];
            this.activated = _data["activated"];
            this.langKey = _data["langKey"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["authorities"])) {
                this.authorities = [] as any;
                for (let item of _data["authorities"])
                    this.authorities!.push(item);
            }
        }
    }

    static fromJS(data: any): AdminUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AdminUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["login"] = this.login;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["imageUrl"] = this.imageUrl;
        data["activated"] = this.activated;
        data["langKey"] = this.langKey;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        if (Array.isArray(this.authorities)) {
            data["authorities"] = [];
            for (let item of this.authorities)
                data["authorities"].push(item);
        }
        return data;
    }
}

export interface IAdminUserDTO {
    id?: number;
    login: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    imageUrl?: string;
    activated?: boolean;
    langKey?: string;
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    authorities?: string[];

    [key: string]: any;
}

export class ManagedUserVM implements IManagedUserVM {
    id?: number;
    login!: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    imageUrl?: string;
    activated?: boolean;
    langKey?: string;
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    authorities?: string[];
    password?: string;

    [key: string]: any;

    constructor(data?: IManagedUserVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.login = _data["login"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.imageUrl = _data["imageUrl"];
            this.activated = _data["activated"];
            this.langKey = _data["langKey"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["authorities"])) {
                this.authorities = [] as any;
                for (let item of _data["authorities"])
                    this.authorities!.push(item);
            }
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ManagedUserVM {
        data = typeof data === 'object' ? data : {};
        let result = new ManagedUserVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["login"] = this.login;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["imageUrl"] = this.imageUrl;
        data["activated"] = this.activated;
        data["langKey"] = this.langKey;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        if (Array.isArray(this.authorities)) {
            data["authorities"] = [];
            for (let item of this.authorities)
                data["authorities"].push(item);
        }
        data["password"] = this.password;
        return data;
    }
}

export interface IManagedUserVM {
    id?: number;
    login: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    imageUrl?: string;
    activated?: boolean;
    langKey?: string;
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    authorities?: string[];
    password?: string;

    [key: string]: any;
}

export class LoginVM implements ILoginVM {
    username!: string;
    password!: string;
    rememberMe?: boolean;

    [key: string]: any;

    constructor(data?: ILoginVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.username = _data["username"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginVM {
        data = typeof data === 'object' ? data : {};
        let result = new LoginVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["username"] = this.username;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface ILoginVM {
    username: string;
    password: string;
    rememberMe?: boolean;

    [key: string]: any;
}

export class JWTToken implements IJWTToken {
    id_token?: string;

    [key: string]: any;

    constructor(data?: IJWTToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id_token = _data["id_token"];
        }
    }

    static fromJS(data: any): JWTToken {
        data = typeof data === 'object' ? data : {};
        let result = new JWTToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id_token"] = this.id_token;
        return data;
    }
}

export interface IJWTToken {
    id_token?: string;

    [key: string]: any;
}

export class User implements IUser {
    id?: number;
    login!: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    activated!: boolean;
    langKey?: string;
    imageUrl?: string;
    resetDate?: Date;

    [key: string]: any;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.login = _data["login"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.activated = _data["activated"];
            this.langKey = _data["langKey"];
            this.imageUrl = _data["imageUrl"];
            this.resetDate = _data["resetDate"] ? new Date(_data["resetDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["login"] = this.login;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["activated"] = this.activated;
        data["langKey"] = this.langKey;
        data["imageUrl"] = this.imageUrl;
        data["resetDate"] = this.resetDate ? this.resetDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUser {
    id?: number;
    login: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    activated: boolean;
    langKey?: string;
    imageUrl?: string;
    resetDate?: Date;

    [key: string]: any;
}

export class KeyAndPasswordVM implements IKeyAndPasswordVM {
    key?: string;
    newPassword?: string;

    [key: string]: any;

    constructor(data?: IKeyAndPasswordVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.key = _data["key"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): KeyAndPasswordVM {
        data = typeof data === 'object' ? data : {};
        let result = new KeyAndPasswordVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["key"] = this.key;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IKeyAndPasswordVM {
    key?: string;
    newPassword?: string;

    [key: string]: any;
}

export class PasswordChangeDTO implements IPasswordChangeDTO {
    currentPassword?: string;
    newPassword?: string;

    [key: string]: any;

    constructor(data?: IPasswordChangeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): PasswordChangeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordChangeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IPasswordChangeDTO {
    currentPassword?: string;
    newPassword?: string;

    [key: string]: any;
}

export class UserDTO implements IUserDTO {
    id?: number;
    login?: string;

    [key: string]: any;

    constructor(data?: IUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.login = _data["login"];
        }
    }

    static fromJS(data: any): UserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["login"] = this.login;
        return data;
    }
}

export interface IUserDTO {
    id?: number;
    login?: string;

    [key: string]: any;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}